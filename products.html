<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Explore our premium collection of digital products including music production tools, FPS utilities, design software, development tools, and productivity solutions for professionals.">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://accounts.google.com; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://accounts.google.com https://plausible.io; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://api.ipify.org https://api.emailjs.com https://accounts.google.com https://plausible.io https://qualitics-production-1.onrender.com https://ipapi.co https://api.my-ip.io https://httpbin.org; img-src 'self' data: https:; frame-src 'self' https://accounts.google.com; object-src 'none'; base-uri 'self'; form-action 'self'; upgrade-insecure-requests; block-all-mixed-content">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">
    <title>Digital Products ‚Äî Premium Solutions | Qualitics Production</title>
    <link rel="canonical" href="https://qualitics-production-1.onrender.com/products.html">
    <link rel="preload" href="style.css" as="style">
    <link href="style.css" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    <noscript><link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet"></noscript>
    <!-- Preconnect for faster third-party loading -->
    <link rel="preconnect" href="https://accounts.google.com" crossorigin>
    <link rel="preconnect" href="https://api.emailjs.com" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js" defer></script>
</head>
<body class="page-products">
    <!-- Navigation -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">
                <span class="logo-text">QUALITICS</span>
                <span class="logo-sub">PRODUCTION</span>
            </div>
            <div class="nav-links">
                <a href="index.html" class="nav-link">Home</a>
                <a href="products.html" class="nav-link active">Products</a>
                <a href="purchase.html" class="nav-link">Purchase</a>
                <a href="dashboard.html" class="nav-link dashboard-link" id="dashboardLink" style="display: none;">Dashboard</a>
                <button class="auth-btn" id="authBtn">Sign In</button>
            </div>
        </div>
    </nav>

    <!-- Page Transition Overlay -->
    <div class="page-transition" id="pageTransition"></div>

    <!-- Products Hero -->
    <section class="products-hero">
        <div class="container">
            <h1 class="page-title">Digital Products ‚Äî Premium Solutions Collection</h1>
            <p class="page-subtitle">Discover Our Cutting-Edge Digital Tools</p>

        </div>
        <div class="hero-particles" id="heroParticles"></div>
    </section>

    <!-- Category Filter -->
    <section class="category-section">
        <div class="container">
            <h2 class="section-title">Browse by Category</h2>
            <div class="category-grid" id="categoryGrid">
                <!-- Categories will be loaded here -->
            </div>
        </div>
    </section>

    <!-- Products Grid -->
    <section class="products-section">
        <div class="container">
            <div class="search-bar-container">
                <input type="text" id="productSearch" placeholder="üîç Search products" class="product-search-bar">
                <select id="categoryFilter" class="category-filter">
                    <option value="">All Categories</option>
                    <option value="music">üéµ Music Production</option>
                    <option value="fps">üéØ First Person Shooters</option>
                    <option value="design">üé® Design & Graphics</option>
                    <option value="development">üíª Development Tools</option>
                    <option value="productivity">‚ö° Productivity</option>
                    <option value="gaming">üéÆ Gaming Utilities</option>
                    <option value="security">üîí Security & Privacy</option>
                    <option value="other">üì¶ Other</option>
                </select>
                <div class="search-info">
                    <span id="searchResults">Showing all products</span>
                </div>
            </div>
            <div class="products-grid" id="productsGrid">
                <!-- Products will be dynamically loaded -->
            </div>
            <div class="no-products" id="noProductsMessage" style="display: none;">
                <h3>No products found</h3>
                <p>Try adjusting your search terms</p>
            </div>
        </div>
    </section>

    <!-- Product Modal -->
    <div id="productModal" class="modal">
        <div class="modal-content product-modal-content">
            <span class="close">&times;</span>
            <div class="product-detail" id="productDetail">
                <!-- Product details will be loaded here -->
            </div>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-logo">
                    <span class="logo-text">QUALITICS</span>
                    <span class="logo-sub">PRODUCTION</span>
                </div>
                <div class="footer-buttons">
                    <a href="privacy-policy.html" class="footer-btn">Privacy Policy</a>
                    <a href="terms-of-service.html" class="footer-btn">Terms of Service</a>
                    <a href="support.html" class="footer-btn">Support</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Qualitics Production. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="script.js" defer></script>
</body>
</html>

    <script>
        // View tracking system with 6-second timer to prevent spam
        let viewTracking = {
            viewedProducts: new Set(),
            viewTimers: new Map()
        };

        function trackProductView(productId) {
            // Check if this product was already viewed by this user in the last 6 seconds
            if (viewTracking.viewedProducts.has(productId)) {
                return; // Already counted this view
            }

            // Add to viewed products set
            viewTracking.viewedProducts.add(productId);

            // Increment view count in localStorage
            let products = JSON.parse(localStorage.getItem('products') || '[]');
            const productIndex = products.findIndex(p => p.id === productId);
            
            if (productIndex !== -1) {
                products[productIndex].views = (products[productIndex].views || 0) + 1;
                localStorage.setItem('products', JSON.stringify(products));
                
                console.log(`View tracked for product ${productId}. New count: ${products[productIndex].views}`);
            }

            // Set timer to remove from viewed set after 6 seconds
            const timer = setTimeout(() => {
                viewTracking.viewedProducts.delete(productId);
                viewTracking.viewTimers.delete(productId);
            }, 6000);

            viewTracking.viewTimers.set(productId, timer);
        }

        // Override the existing openProductDetailModal function to include view tracking
        function openProductDetailModal(productId) {
            // Track the view
            trackProductView(productId);

            // Get product data
            const products = JSON.parse(localStorage.getItem('products') || '[]');
            const product = products.find(p => p.id === productId);
            
            if (!product) {
                console.error('Product not found:', productId);
                return;
            }

            const modal = document.getElementById('productModal');
            const productDetail = document.getElementById('productDetail');
            
            if (!modal || !productDetail) {
                console.error('Modal elements not found');
                return;
            }

            // Create product detail HTML
            productDetail.innerHTML = `
                <div class="product-detail-header">
                    <h2>${product.title}</h2>
                    <div class="product-meta">
                        <span class="product-category">${getCategoryDisplayName(product.category)}</span>
                        <span class="product-views">üëÅÔ∏è ${product.views || 0} views</span>
                    </div>
                </div>
                <div class="product-detail-content">
                    ${product.image ? `<img src="${product.image}" alt="${product.title}" class="product-detail-image">` : ''}
                    <div class="product-info">
                        <div class="product-price">${product.price}</div>
                        <div class="product-description">${product.description || 'No description available'}</div>
                        <div class="product-actions">
                            <button onclick="addToCart('${product.id}')" class="add-to-cart-btn">
                                Add to Cart
                            </button>
                            ${product.youtube ? `<a href="${product.youtube}" target="_blank" class="youtube-link">üé• View Demo</a>` : ''}
                            ${product.external ? `<a href="${product.external}" target="_blank" class="external-link">üîó External Link</a>` : ''}
                        </div>
                    </div>
                </div>
            `;

            modal.style.display = 'block';
        }

        function closeProductDetailModal() {
            const modal = document.getElementById('productModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function getCategoryDisplayName(category) {
            const categoryMap = {
                'music': 'üéµ Music Production',
                'fps': 'üéØ First Person Shooters',
                'design': 'üé® Design & Graphics',
                'development': 'üíª Development Tools',
                'productivity': '‚ö° Productivity',
                'gaming': 'üéÆ Gaming Utilities',
                'security': 'üîí Security & Privacy',
                'other': 'üì¶ Other'
            };
            return categoryMap[category] || 'üì¶ Other';
        }

        // Update the displayProducts function to include click handlers for view tracking
        function displayProducts(productsToShow = null) {
            // Always get fresh data from localStorage
            const products = productsToShow || JSON.parse(localStorage.getItem('products') || '[]');
            const productsGrid = document.getElementById('productsGrid');
            const noProductsMessage = document.getElementById('noProductsMessage');
            const searchResults = document.getElementById('searchResults');

            console.log(`Displaying ${products.length} products on products page`);

            if (!productsGrid) return;

            if (products.length === 0) {
                productsGrid.innerHTML = '';
                if (noProductsMessage) noProductsMessage.style.display = 'block';
                if (searchResults) searchResults.textContent = 'No products found';
                return;
            }

            if (noProductsMessage) noProductsMessage.style.display = 'none';
            if (searchResults) searchResults.textContent = `Showing ${products.length} product${products.length !== 1 ? 's' : ''}`;

            // Debug logging for discount display issues
            products.forEach(product => {
                if (product.discount > 0) {
                    console.log('üõçÔ∏è Product with discount found:', {
                        id: product.id,
                        title: product.title,
                        price: product.price,
                        originalPrice: product.originalPrice,
                        discount: product.discount
                    });
                }
            });

            productsGrid.innerHTML = products.map((product, index) => {
                const streakData = getProductStreak(product.id);
                const hasStreak = streakData.count >= 5;
                const streakClass = hasStreak ? 
                    (streakData.count >= 20 ? 'mega-streak' : 
                     streakData.count >= 10 ? 'high-streak' : '') : '';
                
                return `
                <div class="product-card ${hasStreak ? 'has-streak' : ''}" data-product-id="${product.id}">
                    <div class="product-image-container">
                        ${product.image ? 
                            `<img src="${product.image}" alt="${product.title}" class="product-image" loading="lazy">` :
                            '<div class="product-image placeholder">üì¶</div>'
                        }
                    </div>
                    <div class="product-content">
                        <div class="product-header">
                            <div class="product-info-row">
                                <span class="product-info-label">NAME:</span>
                                <span class="product-title">${product.title}</span>
                            </div>
                            <div class="product-info-row">
                                <span class="product-info-label">CATEGORY:</span>
                                <span class="product-category">${getCategoryDisplayName(product.category)}</span>
                            </div>
                            <div class="product-info-row">
                                <span class="product-info-label">PRICE (USD):</span>
                                <span class="product-price">
                                    ${product.discount > 0 ? 
                                        `<span class="discounted-price">${product.price}</span>
                                         <span class="original-price">${product.originalPrice}</span>
                                         <span class="discount-badge">-${product.discount}%</span>` 
                                        : product.price}
                                </span>
                            </div>
                            <div class="product-info-row">
                                <span class="product-info-label">VIEWS:</span>
                                <span class="product-views">üëÅÔ∏è ${product.views || 0}</span>
                            </div>
                        </div>
                        <div class="product-description-section">
                            <span class="product-description-label">DESCRIPTION:</span>
                            <p class="product-description">${product.description || 'No description available'}</p>
                        </div>
                        <div class="product-like-dislike-section">
                            <div class="like-dislike-buttons">
                                <button onclick="handleLikeDislike('${product.id}', 'like')" 
                                        class="like-dislike-btn like-btn" 
                                        id="like-btn-${product.id}"
                                        data-product-id="${product.id}">
                                    <span class="btn-icon">üíö</span>
                                    <span class="btn-text">LIKE</span>
                                </button>
                                <button onclick="handleLikeDislike('${product.id}', 'dislike')" 
                                        class="like-dislike-btn dislike-btn" 
                                        id="dislike-btn-${product.id}"
                                        data-product-id="${product.id}">
                                    <span class="btn-icon">üíî</span>
                                    <span class="btn-text">DISLIKE</span>
                                </button>
                            </div>
                            ${hasStreak ? `
                                <div class="product-streak-info">
                                    <div class="streak-badge ${streakClass}" id="streak-badge-${product.id}">
                                        <span class="streak-number">${streakData.count}</span>
                                        <span class="streak-label">STREAK</span>
                                    </div>
                                    <div class="streak-timer" id="streak-timer-${product.id}">
                                        Resets in: ${getStreakTimeRemaining(streakData.resetTime)}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="product-actions">
                            <button onclick="addToCart('${product.id}')" class="product-btn cart-btn full-width ${isProductInCart && isProductInCart(product.id) ? 'in-cart' : ''}" ${isProductInCart && isProductInCart(product.id) ? 'disabled' : ''}>
                                <span class="btn-icon">${isProductInCart && isProductInCart(product.id) ? '‚úì' : 'üõí'}</span>
                                <span class="btn-text">${isProductInCart && isProductInCart(product.id) ? 'ADDED TO CART' : 'ADD TO CART'}</span>
                            </button>
                        </div>
                    </div>
                </div>
                `;
            }).join('');

            // Update cart button states after rendering
            setTimeout(updateProductButtons, 100);
            
            // Initialize like/dislike system for all products
            setTimeout(initializeLikeDislikeSystem, 150);
        }

        // NEW Like/Dislike System - localStorage Implementation with Animations
        function initializeLikeDislikeSystem() {
            // Initialize user preferences storage if not exists
            if (!localStorage.getItem('userLikeDislikePreferences')) {
                localStorage.setItem('userLikeDislikePreferences', JSON.stringify({}));
            }
            
            // Update all visible product like/dislike buttons
            const products = JSON.parse(localStorage.getItem('products') || '[]');
            products.forEach(product => {
                updateLikeDislikeButtonsUI(product.id);
            });
        }

        function getUserLikeDislikePreference(productId) {
            const preferences = JSON.parse(localStorage.getItem('userLikeDislikePreferences') || '{}');
            return preferences[productId] || null; // null, 'like', or 'dislike'
        }

        function setUserLikeDislikePreference(productId, preference) {
            const preferences = JSON.parse(localStorage.getItem('userLikeDislikePreferences') || '{}');
            preferences[productId] = preference;
            localStorage.setItem('userLikeDislikePreferences', JSON.stringify(preferences));
        }

        function handleLikeDislike(productId, action) {
            const currentPreference = getUserLikeDislikePreference(productId);
            let newPreference = null;
            
            // Determine new preference based on current state
            if (currentPreference === action) {
                // User clicked same button - remove preference
                newPreference = null;
            } else {
                // User clicked different button or no previous preference
                newPreference = action;
            }
            
            // Save user preference
            setUserLikeDislikePreference(productId, newPreference);
            
            // Update UI with animation
            updateLikeDislikeButtonsUI(productId);
            
            // Show feedback toast
            showLikeDislikeFeedback(action, newPreference);
            
            console.log(`Product ${productId} like/dislike updated:`, {
                oldPreference: currentPreference,
                newPreference: newPreference
            });
        }

        function updateLikeDislikeButtonsUI(productId) {
            const likeBtn = document.getElementById(`like-btn-${productId}`);
            const dislikeBtn = document.getElementById(`dislike-btn-${productId}`);
            const userPreference = getUserLikeDislikePreference(productId);
            
            if (!likeBtn || !dislikeBtn) return;
            
            // Reset button states
            likeBtn.classList.remove('liked', 'pulse-animation');
            dislikeBtn.classList.remove('disliked', 'pulse-animation');
            
            // Set active state based on user preference with animations
            if (userPreference === 'like') {
                likeBtn.classList.add('liked', 'pulse-animation');
                likeBtn.querySelector('.btn-icon').textContent = 'üíö';
                likeBtn.querySelector('.btn-text').textContent = 'LIKED';
            } else {
                likeBtn.querySelector('.btn-icon').textContent = 'ü§ç';
                likeBtn.querySelector('.btn-text').textContent = 'LIKE';
            }
            
            if (userPreference === 'dislike') {
                dislikeBtn.classList.add('disliked', 'pulse-animation');
                dislikeBtn.querySelector('.btn-icon').textContent = 'üíî';
                dislikeBtn.querySelector('.btn-text').textContent = 'DISLIKED';
            } else {
                dislikeBtn.querySelector('.btn-icon').textContent = 'üñ§';
                dislikeBtn.querySelector('.btn-text').textContent = 'DISLIKE';
            }
            
            // Remove pulse animation after a brief delay
            setTimeout(() => {
                likeBtn.classList.remove('pulse-animation');
                dislikeBtn.classList.remove('pulse-animation');
            }, 600);
        }

        function showLikeDislikeFeedback(action, newPreference) {
            let message = '';
            let toastType = 'info';
            
            if (newPreference === 'like') {
                message = 'üíö You liked this product!';
                toastType = 'success';
            } else if (newPreference === 'dislike') {
                message = 'üíî You disliked this product';
                toastType = 'warning';
            } else if (action === 'like') {
                message = 'ü§ç Like removed';
                toastType = 'info';
            } else {
                message = 'üñ§ Dislike removed';
                toastType = 'info';
            }
            
            // Use existing toast system if available
            if (window.showToast) {
                window.showToast(message, toastType);
            } else {
                console.log(`LIKE/DISLIKE FEEDBACK: ${message}`);
            }
        }

        // Auto-refresh products display every 10 seconds to keep it in sync with dashboard
        setInterval(() => {
            const currentProducts = JSON.parse(localStorage.getItem('products') || '[]');
            const displayedCards = document.querySelectorAll('.product-card').length;
            if (currentProducts.length !== displayedCards) {
                console.log('Product count mismatch detected, refreshing display...');
                displayProducts();
            }
        }, 10000);

        // Product Streak System - 24 Hour Purchase Tracking
        function initializeStreakSystem() {
            // Initialize streak storage if not exists
            if (!localStorage.getItem('productStreaks')) {
                localStorage.setItem('productStreaks', JSON.stringify({}));
            }
            
            // Clean up expired streaks on initialization
            cleanupExpiredStreaks();
        }

        function getProductStreak(productId) {
            const streaks = JSON.parse(localStorage.getItem('productStreaks') || '{}');
            const now = Date.now();
            const streak = streaks[productId] || { count: 0, purchases: [], resetTime: now + (24 * 60 * 60 * 1000) };
            
            // Remove purchases older than 24 hours
            const validPurchases = streak.purchases.filter(timestamp => {
                return (now - timestamp) < (24 * 60 * 60 * 1000);
            });
            
            // Update streak count and reset time if needed
            if (validPurchases.length !== streak.purchases.length) {
                streak.purchases = validPurchases;
                streak.count = validPurchases.length;
                
                // Set new reset time based on oldest valid purchase
                if (validPurchases.length > 0) {
                    const oldestPurchase = Math.min(...validPurchases);
                    streak.resetTime = oldestPurchase + (24 * 60 * 60 * 1000);
                } else {
                    streak.resetTime = now + (24 * 60 * 60 * 1000);
                }
                
                // Save updated streak
                streaks[productId] = streak;
                localStorage.setItem('productStreaks', JSON.stringify(streaks));
            }
            
            return streak;
        }

        function addProductPurchase(productId) {
            const streaks = JSON.parse(localStorage.getItem('productStreaks') || '{}');
            const now = Date.now();
            
            if (!streaks[productId]) {
                streaks[productId] = { count: 0, purchases: [], resetTime: now + (24 * 60 * 60 * 1000) };
            }
            
            // Add new purchase timestamp
            streaks[productId].purchases.push(now);
            streaks[productId].count = streaks[productId].purchases.length;
            
            // Update reset time to 24 hours from now if this is a new streak
            if (streaks[productId].count === 1) {
                streaks[productId].resetTime = now + (24 * 60 * 60 * 1000);
            }
            
            localStorage.setItem('productStreaks', JSON.stringify(streaks));
            
            // Show streak notification if applicable
            showStreakNotification(productId, streaks[productId].count);
            
            // Refresh product display to show new streak badge
            setTimeout(() => {
                displayProducts();
            }, 100);
            
            console.log(`Product ${productId} purchased. New streak count: ${streaks[productId].count}`);
            return streaks[productId];
        }

        function cleanupExpiredStreaks() {
            const streaks = JSON.parse(localStorage.getItem('productStreaks') || '{}');
            const now = Date.now();
            let hasChanges = false;
            
            Object.keys(streaks).forEach(productId => {
                const validPurchases = streaks[productId].purchases.filter(timestamp => {
                    return (now - timestamp) < (24 * 60 * 60 * 1000);
                });
                
                if (validPurchases.length !== streaks[productId].purchases.length) {
                    streaks[productId].purchases = validPurchases;
                    streaks[productId].count = validPurchases.length;
                    hasChanges = true;
                    
                    if (validPurchases.length === 0) {
                        delete streaks[productId];
                    }
                }
            });
            
            if (hasChanges) {
                localStorage.setItem('productStreaks', JSON.stringify(streaks));
                console.log('Expired streaks cleaned up');
            }
        }

        function getStreakTimeRemaining(resetTime) {
            const now = Date.now();
            const remaining = resetTime - now;
            
            if (remaining <= 0) {
                return 'Expired';
            }
            
            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m`;
            }
        }

        function showStreakNotification(productId, count) {
            let message = '';
            let toastType = 'info';
            
            if (count === 5) {
                message = `üî• Product is now on a streak! ${count} purchases in 24h`;
                toastType = 'success';
            } else if (count >= 10 && count < 20) {
                message = `üî•üî• Hot streak! ${count} purchases and counting!`;
                toastType = 'success';
            } else if (count >= 20) {
                message = `üî•üî•üî• MEGA STREAK! ${count} purchases - This is trending!`;
                toastType = 'success';
            } else if (count > 5) {
                message = `üî• Streak continues: ${count} purchases`;
                toastType = 'success';
            }
            
            if (message && window.showToast) {
                window.showToast(message, toastType);
            }
        }

        // Override existing addToCart function to include streak tracking
        const originalAddToCart = window.addToCart;
        window.addToCart = function(productId) {
            // Call original addToCart function
            if (originalAddToCart) {
                const result = originalAddToCart(productId);
                
                // Add purchase to streak system
                addProductPurchase(productId);
                
                return result;
            } else {
                // Fallback if original function doesn't exist
                addProductPurchase(productId);
                console.log(`Product ${productId} added to cart and streak updated`);
            }
        };

        // Update streak timers every minute
        setInterval(() => {
            const streakTimers = document.querySelectorAll('[id^="streak-timer-"]');
            streakTimers.forEach(timer => {
                const productId = timer.id.replace('streak-timer-', '');
                const streakData = getProductStreak(productId);
                timer.textContent = getStreakTimeRemaining(streakData.resetTime);
            });
            
            // Clean up expired streaks periodically
            cleanupExpiredStreaks();
        }, 60000); // Update every minute

        // Testing function to simulate purchases for demonstration
        window.simulateProductPurchases = function(productId, count = 6) {
            console.log(`Simulating ${count} purchases for product ${productId}...`);
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    addProductPurchase(productId);
                    if (i === count - 1) {
                        console.log(`Simulation complete! Product ${productId} now has ${count} purchases.`);
                        window.showToast(`üî• Simulated ${count} purchases for testing!`, 'success');
                    }
                }, i * 200); // Slight delay between purchases
            }
        };

        // Testing function to reset all streaks
        window.resetAllStreaks = function() {
            localStorage.setItem('productStreaks', JSON.stringify({}));
            displayProducts();
            console.log('All product streaks have been reset');
            window.showToast('All streaks reset for testing', 'info');
        };

        // Initialize systems when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializeLikeDislikeSystem, 100);
            setTimeout(initializeStreakSystem, 150);
        });
    </script>
